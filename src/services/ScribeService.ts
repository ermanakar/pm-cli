import path from 'path';
import { FileSystemService } from './FileSystemService.js';
import { LLMService, ChatMessage } from './LLMService.js';
import { MemoryService } from './MemoryService.js';
import { InvestigatorAgent } from './InvestigatorAgent.js';
import { MCPService } from './MCPService.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOCUMENT TEMPLATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PRD_TEMPLATE = `
# Product Requirements Document: {{TOPIC}}

## Overview
{{OVERVIEW}}

## Strategic Alignment
{{STRATEGIC_ALIGNMENT}}

## Target Personas
{{PERSONAS}}

## User Stories
{{USER_STORIES}}

## Technical Considerations
{{TECHNICAL}}

## Acceptance Criteria
{{ACCEPTANCE_CRITERIA}}

## Risks & Mitigations
{{RISKS}}

## Success Metrics
{{METRICS}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

const TICKET_TEMPLATE = `
# {{TOPIC}}

## Summary
{{SUMMARY}}

## Context
{{CONTEXT}}

## Acceptance Criteria
{{ACCEPTANCE_CRITERIA}}

## Technical Notes
{{TECHNICAL}}

## Related Files
{{RELATED_FILES}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

const SPEC_TEMPLATE = `
# Technical Specification: {{TOPIC}}

## Background
{{BACKGROUND}}

## Proposed Solution
{{SOLUTION}}

## Architecture
{{ARCHITECTURE}}

## API Changes
{{API}}

## Database Changes
{{DATABASE}}

## Testing Strategy
{{TESTING}}

## Rollout Plan
{{ROLLOUT}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SMART SCRIBE SERVICE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface ScribeOptions {
    investigate?: boolean;      // Should we investigate codebase first?
    includeMemory?: boolean;    // Include OKRs, decisions, personas?
    syncToConfluence?: boolean; // Push to Confluence (future)
    createJiraTickets?: boolean; // Create Jira tickets from ACs (future)
}

export interface ScribeResult {
    filename: string;
    content: string;
    type: string;
    topic: string;
}

export class ScribeService {
    private readonly MAX_FILENAME_LENGTH = 50; // Max chars for the topic portion

    constructor(
        private fileSystem: FileSystemService,
        private llm: LLMService,
        private memoryService?: MemoryService,
        private investigatorAgent?: InvestigatorAgent,
        private mcpService?: MCPService
    ) { }

    /**
     * Generate a safe, sanitized filename from a topic.
     * - Removes special characters
     * - Converts to lowercase kebab-case
     * - Truncates to max length
     * - Ensures it ends on a word boundary when possible
     */
    private generateSafeFilename(type: string, topic: string): string {
        // 1. Remove special characters, keep only alphanumeric and spaces
        let sanitized = topic
            .replace(/[^\w\s-]/g, '') // Remove special chars except spaces and hyphens
            .replace(/\s+/g, '-')      // Replace spaces with hyphens
            .replace(/-+/g, '-')       // Collapse multiple hyphens
            .toLowerCase()
            .trim();

        // 2. Truncate to max length, trying to end on a word boundary
        if (sanitized.length > this.MAX_FILENAME_LENGTH) {
            sanitized = sanitized.slice(0, this.MAX_FILENAME_LENGTH);

            // Try to end on a hyphen (word boundary)
            const lastHyphen = sanitized.lastIndexOf('-');
            if (lastHyphen > this.MAX_FILENAME_LENGTH * 0.6) {
                sanitized = sanitized.slice(0, lastHyphen);
            }
        }

        // 3. Remove trailing hyphens
        sanitized = sanitized.replace(/-+$/, '');

        // 4. Fallback if empty
        if (!sanitized) {
            sanitized = 'untitled';
        }

        return `docs/${type.toLowerCase()}-${sanitized}.md`;
    }

    /**
     * Generate a context-aware document artifact.
     * 
     * Smart Scribe will:
     * 1. Investigate the codebase for relevant context
     * 2. Pull strategic memory (OKRs, decisions, personas)
     * 3. Generate structured content using templates
     * 4. Optionally sync to Confluence/Jira
     */
    async generateArtifact(
        type: string,
        topic: string,
        providedContext?: string,
        options: ScribeOptions = { investigate: true, includeMemory: true },
        onProgress?: (step: string) => void
    ): Promise<ScribeResult> {

        const contextParts: string[] = [];

        // 1. Investigate codebase for relevant context
        if (options.investigate && this.investigatorAgent) {
            onProgress?.('ğŸ” Investigating codebase for relevant patterns...');
            const codebaseContext = await this.investigateForTopic(type, topic);
            if (codebaseContext) {
                contextParts.push(`## Codebase Analysis\n${codebaseContext}`);
                onProgress?.('âœ“ Found relevant code context');
            }
        }

        // 2. Get strategic memory context
        if (options.includeMemory && this.memoryService) {
            onProgress?.('ğŸ¯ Loading strategic memory (OKRs, personas, decisions)...');
            const memoryContext = await this.getMemoryContext();
            if (memoryContext) {
                contextParts.push(memoryContext);
                onProgress?.('âœ“ Strategic context loaded');
            }
        }

        // 3. Add any provided context
        if (providedContext) {
            contextParts.push(`## Additional Context\n${providedContext}`);
        }

        const fullContext = contextParts.join('\n\n');

        // 4. Generate content using appropriate template
        onProgress?.(`ğŸ“ Generating ${type.toUpperCase()} with AI...`);
        const content = await this.generateWithTemplate(type, topic, fullContext);
        onProgress?.('âœ“ Document generated');

        // 5. Save to file
        onProgress?.('ğŸ’¾ Saving to docs/...');
        const filename = this.generateSafeFilename(type, topic);
        await this.fileSystem.writeFile(filename, content);

        // Note: Confluence/Jira sync is now handled separately in Chat.tsx
        // with user confirmation before creating tickets

        onProgress?.('âœ… Complete!');

        return {
            filename,
            content,
            type,
            topic
        };
    }

    /**
     * Investigate the codebase for context relevant to the topic.
     */
    private async investigateForTopic(type: string, topic: string): Promise<string | null> {
        if (!this.investigatorAgent) return null;

        const investigationPrompt = this.getInvestigationPrompt(type, topic);

        try {
            const result = await this.investigatorAgent.investigate(investigationPrompt);
            return result;
        } catch (e) {
            console.error('Investigation failed:', e);
            return null;
        }
    }

    private getInvestigationPrompt(type: string, topic: string): string {
        const prompts: Record<string, string> = {
            prd: `Analyze the codebase to understand how "${topic}" could be implemented or improved.
                  Look for:
                  1. Existing related components or patterns
                  2. Database schemas that might be affected
                  3. API endpoints that relate to this feature
                  4. UI components that could be reused
                  5. Any existing partial implementations
                  
                  Be concise. Focus on what exists and what would need to change.`,

            ticket: `Find all code related to "${topic}".
                     Identify:
                     1. The specific files that would need changes
                     2. Any dependencies or side effects
                     3. Testing requirements
                     
                     Be specific about file paths.`,

            spec: `Analyze the technical architecture around "${topic}".
                   Document:
                   1. Current implementation patterns
                   2. Database structure
                   3. API design
                   4. Integration points
                   
                   Focus on technical details.`,

            default: `Find information about "${topic}" in the codebase.
                      Note any relevant files, patterns, or existing implementations.`
        };

        return prompts[type.toLowerCase()] || prompts.default;
    }

    /**
     * Get formatted memory context for document generation.
     */
    private async getMemoryContext(): Promise<string | null> {
        if (!this.memoryService) return null;

        const parts: string[] = [];

        // OKRs
        const okrs = await this.memoryService.getOKRs();
        if (okrs.length > 0) {
            const okrLines = okrs.map(o =>
                `- [${o.status}] ${o.objective} (${o.quarter})`
            ).join('\n');
            parts.push(`## Current OKRs\n${okrLines}`);
        }

        // Personas
        const personas = await this.memoryService.getPersonas();
        if (personas.length > 0) {
            const personaLines = personas.map(p => {
                const goals = p.goals.length > 0 ? ` Goals: ${p.goals.join(', ')}` : '';
                return `- **${p.name}** (${p.role})${goals}`;
            }).join('\n');
            parts.push(`## Target Personas\n${personaLines}`);
        }

        // Recent Decisions
        const decisions = await this.memoryService.getDecisions(3);
        if (decisions.length > 0) {
            const decisionLines = decisions.map(d =>
                `- ${d.title}: ${d.decision}`
            ).join('\n');
            parts.push(`## Recent Decisions\n${decisionLines}`);
        }

        // Open Risks
        const risks = await this.memoryService.getOpenRisks();
        if (risks.length > 0) {
            const riskLines = risks.map(r =>
                `- [${r.likelihood}/${r.impact}] ${r.title}`
            ).join('\n');
            parts.push(`## Open Risks\n${riskLines}`);
        }

        return parts.length > 0 ? parts.join('\n\n') : null;
    }

    /**
     * Generate document content using templates and LLM.
     */
    private async generateWithTemplate(type: string, topic: string, context: string): Promise<string> {
        const template = this.getTemplate(type);
        const systemPrompt = this.getSystemPrompt(type);

        const prompt: ChatMessage[] = [
            {
                role: 'system',
                content: systemPrompt
            },
            {
                role: 'user',
                content: `Create a ${type.toUpperCase()} for: "${topic}"

CONTEXT FROM CODEBASE AND STRATEGIC MEMORY:
${context || 'No additional context available.'}

TEMPLATE TO FOLLOW:
${template}

Generate comprehensive, actionable content. Fill in all sections.
For Acceptance Criteria, use clear Given/When/Then format.
Be specific and reference actual code patterns from the context when available.`
            }
        ];

        const content = await this.llm.chatCompletion(prompt);
        if (!content) throw new Error('Failed to generate content');

        return content;
    }

    private getTemplate(type: string): string {
        const templates: Record<string, string> = {
            prd: PRD_TEMPLATE,
            ticket: TICKET_TEMPLATE,
            spec: SPEC_TEMPLATE
        };
        return templates[type.toLowerCase()] || templates.prd;
    }

    private getSystemPrompt(type: string): string {
        const prompts: Record<string, string> = {
            prd: `You are PMX Scribe, an expert Product Manager.
                  Create detailed, actionable Product Requirements Documents.
                  
                  Key principles:
                  - Align features with OKRs and business goals
                  - Consider all target personas
                  - Be specific about acceptance criteria
                  - Reference existing code patterns when relevant
                  - Identify risks and mitigations
                  
                  Output clean Markdown.`,

            ticket: `You are PMX Scribe, an expert Engineering Manager.
                     Create clear, well-scoped tickets that engineers can pick up immediately.
                     
                     Key principles:
                     - One ticket = one clear deliverable
                     - Include specific file paths when known
                     - Acceptance criteria in Given/When/Then format
                     - Note dependencies and blockers
                     
                     Output clean Markdown.`,

            spec: `You are PMX Scribe, an expert Technical Architect.
                   Create detailed technical specifications.
                   
                   Key principles:
                   - Document current state and proposed changes
                   - Include API contracts and data models
                   - Consider performance and scalability
                   - Plan for testing and rollout
                   
                   Output clean Markdown.`,

            default: `You are PMX Scribe, an expert documentation writer.
                      Create clear, structured documentation.
                      Output clean Markdown.`
        };

        return prompts[type.toLowerCase()] || prompts.default;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // External Sync Implementation
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Check if Atlassian tools are available via MCP.
     */
    async checkAtlassianTools(): Promise<{ hasConfluence: boolean; hasJira: boolean }> {
        if (!this.mcpService) return { hasConfluence: false, hasJira: false };

        try {
            const tools = await this.mcpService.getTools();
            return {
                hasConfluence: tools.some((t: any) => t.function.name === 'confluence_create_page'),
                hasJira: tools.some((t: any) => t.function.name === 'jira_create_issue')
            };
        } catch (e) {
            return { hasConfluence: false, hasJira: false };
        }
    }

    /**
     * Sync document to Confluence.
     */
    async syncToConfluence(
        title: string,
        content: string,
        spaceKey: string
    ): Promise<{ success: boolean; pageUrl?: string; error?: string }> {
        if (!this.mcpService) {
            return { success: false, error: 'MCP service not available' };
        }

        try {
            const result = await this.mcpService.callTool('confluence_create_page', {
                space_key: spaceKey,
                title: `[PMX] ${title}`,
                body: content
            });

            // Try to extract page URL from result
            const urlMatch = result?.match(/https?:\/\/[^\s]+/);
            return {
                success: true,
                pageUrl: urlMatch ? urlMatch[0] : undefined
            };
        } catch (e) {
            return {
                success: false,
                error: (e as Error).message
            };
        }
    }

    /**
     * Create Jira tickets from acceptance criteria.
     */
    async createJiraTicketsFromACs(
        topic: string,
        content: string,
        projectKey: string,
        issueType: string = 'Task'
    ): Promise<{ success: boolean; tickets: string[]; error?: string }> {
        if (!this.mcpService) {
            return { success: false, tickets: [], error: 'MCP service not available' };
        }

        try {
            const acs = this.extractAcceptanceCriteria(content);

            if (acs.length === 0) {
                return { success: true, tickets: [], error: 'No acceptance criteria found in document' };
            }

            const createdTickets: string[] = [];

            for (const ac of acs) {
                try {
                    const result = await this.mcpService.callTool('jira_create_issue', {
                        project_key: projectKey,
                        summary: ac.title.slice(0, 100), // Jira summary limit
                        description: `From PRD: ${topic}\n\n${ac.criteria}`,
                        issue_type: issueType  // Correct parameter name
                    });

                    // Debug: log the raw result to understand format
                    console.log('Jira create result:', result);

                    // Try multiple patterns to extract ticket key
                    // Pattern 1: PROJ-123 anywhere in text
                    const keyMatch = result?.match(/[A-Z]+-\d+/);
                    // Pattern 2: "key": "PROJ-123" in JSON
                    const jsonKeyMatch = result?.match(/"key"\s*:\s*"([A-Z]+-\d+)"/);
                    // Pattern 3: id or self URL containing the key
                    const urlMatch = result?.match(/\/([A-Z]+-\d+)/);

                    if (keyMatch) {
                        createdTickets.push(keyMatch[0]);
                    } else if (jsonKeyMatch) {
                        createdTickets.push(jsonKeyMatch[1]);
                    } else if (urlMatch) {
                        createdTickets.push(urlMatch[1]);
                    } else if (result && result.includes('created') || result.includes('success')) {
                        createdTickets.push('Created (key not returned)');
                    } else {
                        createdTickets.push('Created');
                    }
                } catch (ticketError) {
                    createdTickets.push(`Failed: ${(ticketError as Error).message}`);
                }
            }

            return {
                success: true,
                tickets: createdTickets
            };
        } catch (e) {
            return {
                success: false,
                tickets: [],
                error: (e as Error).message
            };
        }
    }

    /**
     * Get acceptance criteria count without creating tickets (for confirmation).
     */
    getAcceptanceCriteriaCount(content: string): number {
        return this.extractAcceptanceCriteria(content).length;
    }

    /**
     * Get acceptance criteria previews for confirmation.
     */
    getAcceptanceCriteriaPreviews(content: string): string[] {
        return this.extractAcceptanceCriteria(content)
            .map(ac => ac.title.slice(0, 60) + (ac.title.length > 60 ? '...' : ''));
    }

    private extractAcceptanceCriteria(content: string): Array<{ title: string; criteria: string }> {
        // Try multiple patterns for the AC section header
        const patterns = [
            /##\s*Acceptance Criteria\s*\n([\s\S]*?)(?=\n## [A-Z]|$)/i,  // Stop at next ## section
            /##\s*Acceptance\s*\n([\s\S]*?)(?=\n## [A-Z]|$)/i,
            /###\s*Acceptance Criteria\s*\n([\s\S]*?)(?=\n## [A-Z]|$)/i,
        ];

        let acContent: string | null = null;
        for (const pattern of patterns) {
            const match = content.match(pattern);
            if (match) {
                acContent = match[1];
                break;
            }
        }

        if (!acContent) return [];

        const items: Array<{ title: string; criteria: string }> = [];
        const lines = acContent.split('\n');

        let currentItem: { title: string; criteria: string } | null = null;

        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;

            // Only match AC headers - be strict:
            // ### 1) Title  or  ### N) Title  or  **1. Title**
            const headerMatch = trimmed.match(/^###\s*(\d+)[\.\)]\s*(.+)/) ||    // ### 1) or ### 1. Title
                trimmed.match(/^\*\*(\d+)[\.\)]\s*(.+?)\*\*/) || // **1. Title** or **1) Title**
                trimmed.match(/^(\d+)[\.\)]\s+([A-Z].{5,})/);     // 1. or 1) Title (capital start)

            if (headerMatch) {
                if (currentItem) items.push(currentItem);
                const title = headerMatch[2] || headerMatch[1];
                currentItem = {
                    title: title.replace(/\*\*/g, '').trim(),
                    criteria: ''
                };
            } else if (currentItem) {
                // Append content to current item (Given/When/Then etc.)
                currentItem.criteria += trimmed + '\n';
            }
        }

        if (currentItem) items.push(currentItem);

        return items;
    }
}
