import path from 'path';
import { FileSystemService } from './FileSystemService.js';
import { LLMService, ChatMessage } from './LLMService.js';
import { MemoryService } from './MemoryService.js';
import { InvestigatorAgent } from './InvestigatorAgent.js';
import { MCPService } from './MCPService.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOCUMENT TEMPLATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PRD_TEMPLATE = `
# Product Requirements Document: {{TOPIC}}

## Overview
{{OVERVIEW}}

## Strategic Alignment
{{STRATEGIC_ALIGNMENT}}

## Target Personas
{{PERSONAS}}

## User Stories
{{USER_STORIES}}

## Technical Considerations
{{TECHNICAL}}

## Acceptance Criteria
{{ACCEPTANCE_CRITERIA}}

## Risks & Mitigations
{{RISKS}}

## Success Metrics
{{METRICS}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

const TICKET_TEMPLATE = `
# {{TOPIC}}

## Summary
{{SUMMARY}}

## Context
{{CONTEXT}}

## Acceptance Criteria
{{ACCEPTANCE_CRITERIA}}

## Technical Notes
{{TECHNICAL}}

## Related Files
{{RELATED_FILES}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

const SPEC_TEMPLATE = `
# Technical Specification: {{TOPIC}}

## Background
{{BACKGROUND}}

## Proposed Solution
{{SOLUTION}}

## Architecture
{{ARCHITECTURE}}

## API Changes
{{API}}

## Database Changes
{{DATABASE}}

## Testing Strategy
{{TESTING}}

## Rollout Plan
{{ROLLOUT}}

---
*Generated by PMX Scribe | {{DATE}}*
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SMART SCRIBE SERVICE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface ScribeOptions {
    investigate?: boolean;      // Should we investigate codebase first?
    includeMemory?: boolean;    // Include OKRs, decisions, personas?
    syncToConfluence?: boolean; // Push to Confluence (future)
    createJiraTickets?: boolean; // Create Jira tickets from ACs (future)
}

export interface ScribeResult {
    filename: string;
    content: string;
    type: string;
    topic: string;
}

export class ScribeService {
    constructor(
        private fileSystem: FileSystemService,
        private llm: LLMService,
        private memoryService?: MemoryService,
        private investigatorAgent?: InvestigatorAgent,
        private mcpService?: MCPService
    ) { }

    /**
     * Generate a context-aware document artifact.
     * 
     * Smart Scribe will:
     * 1. Investigate the codebase for relevant context
     * 2. Pull strategic memory (OKRs, decisions, personas)
     * 3. Generate structured content using templates
     * 4. Optionally sync to Confluence/Jira
     */
    async generateArtifact(
        type: string,
        topic: string,
        providedContext?: string,
        options: ScribeOptions = { investigate: true, includeMemory: true },
        onProgress?: (step: string) => void
    ): Promise<ScribeResult> {

        const contextParts: string[] = [];

        // 1. Investigate codebase for relevant context
        if (options.investigate && this.investigatorAgent) {
            onProgress?.('ğŸ” Investigating codebase for relevant patterns...');
            const codebaseContext = await this.investigateForTopic(type, topic);
            if (codebaseContext) {
                contextParts.push(`## Codebase Analysis\n${codebaseContext}`);
                onProgress?.('âœ“ Found relevant code context');
            }
        }

        // 2. Get strategic memory context
        if (options.includeMemory && this.memoryService) {
            onProgress?.('ğŸ¯ Loading strategic memory (OKRs, personas, decisions)...');
            const memoryContext = await this.getMemoryContext();
            if (memoryContext) {
                contextParts.push(memoryContext);
                onProgress?.('âœ“ Strategic context loaded');
            }
        }

        // 3. Add any provided context
        if (providedContext) {
            contextParts.push(`## Additional Context\n${providedContext}`);
        }

        const fullContext = contextParts.join('\n\n');

        // 4. Generate content using appropriate template
        onProgress?.(`ğŸ“ Generating ${type.toUpperCase()} with AI...`);
        const content = await this.generateWithTemplate(type, topic, fullContext);
        onProgress?.('âœ“ Document generated');

        // 5. Save to file
        onProgress?.('ğŸ’¾ Saving to docs/...');
        const filename = `docs/${type.toLowerCase()}-${topic.replace(/\s+/g, '-').toLowerCase()}.md`;
        await this.fileSystem.writeFile(filename, content);

        // 6. Optionally sync to external systems (future)
        if (options.syncToConfluence && this.mcpService) {
            onProgress?.('â˜ï¸ Syncing to Confluence...');
            await this.syncToConfluence(topic, content);
        }

        if (options.createJiraTickets && this.mcpService) {
            onProgress?.('ğŸ« Creating Jira tickets...');
            await this.createJiraTicketsFromACs(topic, content);
        }

        onProgress?.('âœ… Complete!');

        return {
            filename,
            content,
            type,
            topic
        };
    }

    /**
     * Investigate the codebase for context relevant to the topic.
     */
    private async investigateForTopic(type: string, topic: string): Promise<string | null> {
        if (!this.investigatorAgent) return null;

        const investigationPrompt = this.getInvestigationPrompt(type, topic);

        try {
            const result = await this.investigatorAgent.investigate(investigationPrompt);
            return result;
        } catch (e) {
            console.error('Investigation failed:', e);
            return null;
        }
    }

    private getInvestigationPrompt(type: string, topic: string): string {
        const prompts: Record<string, string> = {
            prd: `Analyze the codebase to understand how "${topic}" could be implemented or improved.
                  Look for:
                  1. Existing related components or patterns
                  2. Database schemas that might be affected
                  3. API endpoints that relate to this feature
                  4. UI components that could be reused
                  5. Any existing partial implementations
                  
                  Be concise. Focus on what exists and what would need to change.`,

            ticket: `Find all code related to "${topic}".
                     Identify:
                     1. The specific files that would need changes
                     2. Any dependencies or side effects
                     3. Testing requirements
                     
                     Be specific about file paths.`,

            spec: `Analyze the technical architecture around "${topic}".
                   Document:
                   1. Current implementation patterns
                   2. Database structure
                   3. API design
                   4. Integration points
                   
                   Focus on technical details.`,

            default: `Find information about "${topic}" in the codebase.
                      Note any relevant files, patterns, or existing implementations.`
        };

        return prompts[type.toLowerCase()] || prompts.default;
    }

    /**
     * Get formatted memory context for document generation.
     */
    private async getMemoryContext(): Promise<string | null> {
        if (!this.memoryService) return null;

        const parts: string[] = [];

        // OKRs
        const okrs = await this.memoryService.getOKRs();
        if (okrs.length > 0) {
            const okrLines = okrs.map(o =>
                `- [${o.status}] ${o.objective} (${o.quarter})`
            ).join('\n');
            parts.push(`## Current OKRs\n${okrLines}`);
        }

        // Personas
        const personas = await this.memoryService.getPersonas();
        if (personas.length > 0) {
            const personaLines = personas.map(p => {
                const goals = p.goals.length > 0 ? ` Goals: ${p.goals.join(', ')}` : '';
                return `- **${p.name}** (${p.role})${goals}`;
            }).join('\n');
            parts.push(`## Target Personas\n${personaLines}`);
        }

        // Recent Decisions
        const decisions = await this.memoryService.getDecisions(3);
        if (decisions.length > 0) {
            const decisionLines = decisions.map(d =>
                `- ${d.title}: ${d.decision}`
            ).join('\n');
            parts.push(`## Recent Decisions\n${decisionLines}`);
        }

        // Open Risks
        const risks = await this.memoryService.getOpenRisks();
        if (risks.length > 0) {
            const riskLines = risks.map(r =>
                `- [${r.likelihood}/${r.impact}] ${r.title}`
            ).join('\n');
            parts.push(`## Open Risks\n${riskLines}`);
        }

        return parts.length > 0 ? parts.join('\n\n') : null;
    }

    /**
     * Generate document content using templates and LLM.
     */
    private async generateWithTemplate(type: string, topic: string, context: string): Promise<string> {
        const template = this.getTemplate(type);
        const systemPrompt = this.getSystemPrompt(type);

        const prompt: ChatMessage[] = [
            {
                role: 'system',
                content: systemPrompt
            },
            {
                role: 'user',
                content: `Create a ${type.toUpperCase()} for: "${topic}"

CONTEXT FROM CODEBASE AND STRATEGIC MEMORY:
${context || 'No additional context available.'}

TEMPLATE TO FOLLOW:
${template}

Generate comprehensive, actionable content. Fill in all sections.
For Acceptance Criteria, use clear Given/When/Then format.
Be specific and reference actual code patterns from the context when available.`
            }
        ];

        const content = await this.llm.chatCompletion(prompt);
        if (!content) throw new Error('Failed to generate content');

        return content;
    }

    private getTemplate(type: string): string {
        const templates: Record<string, string> = {
            prd: PRD_TEMPLATE,
            ticket: TICKET_TEMPLATE,
            spec: SPEC_TEMPLATE
        };
        return templates[type.toLowerCase()] || templates.prd;
    }

    private getSystemPrompt(type: string): string {
        const prompts: Record<string, string> = {
            prd: `You are PMX Scribe, an expert Product Manager.
                  Create detailed, actionable Product Requirements Documents.
                  
                  Key principles:
                  - Align features with OKRs and business goals
                  - Consider all target personas
                  - Be specific about acceptance criteria
                  - Reference existing code patterns when relevant
                  - Identify risks and mitigations
                  
                  Output clean Markdown.`,

            ticket: `You are PMX Scribe, an expert Engineering Manager.
                     Create clear, well-scoped tickets that engineers can pick up immediately.
                     
                     Key principles:
                     - One ticket = one clear deliverable
                     - Include specific file paths when known
                     - Acceptance criteria in Given/When/Then format
                     - Note dependencies and blockers
                     
                     Output clean Markdown.`,

            spec: `You are PMX Scribe, an expert Technical Architect.
                   Create detailed technical specifications.
                   
                   Key principles:
                   - Document current state and proposed changes
                   - Include API contracts and data models
                   - Consider performance and scalability
                   - Plan for testing and rollout
                   
                   Output clean Markdown.`,

            default: `You are PMX Scribe, an expert documentation writer.
                      Create clear, structured documentation.
                      Output clean Markdown.`
        };

        return prompts[type.toLowerCase()] || prompts.default;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // External Sync (Future Implementation)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private async syncToConfluence(title: string, content: string): Promise<void> {
        if (!this.mcpService) return;

        try {
            // Check if confluence tools are available
            const tools = await this.mcpService.getTools();
            const hasConfluence = tools.some((t: any) => t.function.name === 'confluence_create_page');

            if (hasConfluence) {
                await this.mcpService.callTool('confluence_create_page', {
                    title: `PMX: ${title}`,
                    content: content,
                    // Note: Would need space_key from config
                });
                console.log(`âœ… Synced to Confluence: ${title}`);
            }
        } catch (e) {
            console.error('Confluence sync failed:', e);
        }
    }

    private async createJiraTicketsFromACs(topic: string, content: string): Promise<void> {
        if (!this.mcpService) return;

        try {
            // Check if jira tools are available
            const tools = await this.mcpService.getTools();
            const hasJira = tools.some((t: any) => t.function.name === 'jira_create_issue');

            if (hasJira) {
                // Extract acceptance criteria from content
                const acs = this.extractAcceptanceCriteria(content);

                for (const ac of acs) {
                    await this.mcpService.callTool('jira_create_issue', {
                        summary: `${topic}: ${ac.title}`,
                        description: ac.criteria,
                        // Note: Would need project_key from config
                    });
                }
                console.log(`âœ… Created ${acs.length} Jira tickets`);
            }
        } catch (e) {
            console.error('Jira ticket creation failed:', e);
        }
    }

    private extractAcceptanceCriteria(content: string): Array<{ title: string; criteria: string }> {
        // Simple extraction - looks for numbered AC items
        const acSection = content.match(/## Acceptance Criteria\n([\s\S]*?)(?=\n##|$)/);
        if (!acSection) return [];

        const items: Array<{ title: string; criteria: string }> = [];
        const lines = acSection[1].split('\n').filter(l => l.trim());

        let currentItem: { title: string; criteria: string } | null = null;

        for (const line of lines) {
            if (line.match(/^[\d]+\.|^-\s*\*\*/)) {
                if (currentItem) items.push(currentItem);
                currentItem = { title: line.replace(/^[\d]+\.\s*|^-\s*/, ''), criteria: '' };
            } else if (currentItem) {
                currentItem.criteria += line + '\n';
            }
        }

        if (currentItem) items.push(currentItem);

        return items;
    }
}
